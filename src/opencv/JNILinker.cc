// Implementation (in C++) of the JNILinker.java native methods.
// http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html
//
// Wrap all use of funcs with try/catch

#include <iostream>
#include <stdio.h>
#include <mutex>

#include <jni.h>
#include "JNILinker.h" // generated by javah

#include "StormFuncs.h"

static StormFuncs funcs;
static const std::string prefix("JNI: ");

//==------------------------------------------------------------------
// Utility functions
//==------------------------------------------------------------------

static inline void
jthrow(JNIEnv *env, const char *msg)
{
    jclass e = env->FindClass("java/lang/RuntimeException");
    if (!e) throw std::runtime_error("JNI error: find class");
    env->ThrowNew(e, msg);
}

static inline void
jthrow(JNIEnv *env, std::string &msg)
{
    jthrow(env, msg.data());
}

static std::mutex l;
class Lock {
    public:
    Lock() { l.lock(); }
    ~Lock() { l.unlock(); }
};

static inline void
jcheck(JNIEnv *env)
{
    if (env->ExceptionCheck()) {
        env->ExceptionDescribe();
        assert("JNI hiccup");
    }
}

static inline std::string
J2C_string(JNIEnv *env, jstring jstr)
{
    const char *cstr = env->GetStringUTFChars(jstr, 0);
    std::string str(cstr);
    env->ReleaseStringUTFChars(jstr, cstr);
    return str;
}

static std::deque<std::string>
J2C_hashset(JNIEnv *env, jobject hashset)
{
    std::deque<std::string> deque(0);

    if (!hashset)
        return deque;

    // HashSet<String>::iterator iter;
    jclass cls = env->GetObjectClass(hashset);
    jcheck(env);
    jmethodID getiter = env->GetMethodID(cls,
            "iterator", "()Ljava/util/Iterator;");
    jcheck(env);
    jobject iter = env->CallObjectMethod(hashset, getiter);
    jcheck(env);
    cls = env->GetObjectClass(iter);
    jcheck(env);

    jmethodID hasNext = env->GetMethodID(cls, "hasNext", "()Z");
    jcheck(env);
    jmethodID next = env->GetMethodID(cls,
            "next", "()Ljava/lang/Object;");
    jcheck(env);

    while (env->CallBooleanMethod(iter, hasNext)) {
        jcheck(env);
        jobject obj = env->CallObjectMethod(iter, next);
        jcheck(env);
        jstring str = static_cast<jstring>(obj);
        jcheck(env);
        deque.push_back(J2C_string(env, str));
    }

    return deque;
}

static void
C2J_hashset(JNIEnv *env, std::deque<std::string> &set, jobject hashset)
{
    jclass cls = env->GetObjectClass(hashset);
    jcheck(env);
    jmethodID clear = env->GetMethodID(cls, "clear", "()V");
    jcheck(env);
    env->CallVoidMethod(hashset, clear);
    jcheck(env);

    jmethodID add = env->GetMethodID(cls,
            "add", "(Ljava/lang/Object;)Z");
    jcheck(env);
    for (std::string &item : set) {
        env->CallBooleanMethod(hashset, add,
                env->NewStringUTF(item.c_str()));
        jcheck(env);
    }
}

//==------------------------------------------------------------------
// JNI implementation
//==------------------------------------------------------------------

// int neighbors(String vertex, HashSet<String> others);
JNIEXPORT jint JNICALL Java_JNILinker_neighbors
  (JNIEnv *env, jobject thisobj, jstring vertex, jobject hashset)
{
    Lock lock;

    std::string vertex_cpp(J2C_string(env, vertex));
    std::deque<std::string> others;
    if (0 != funcs.neighbors(vertex_cpp, others))
        return -1;
    if (0 == others.size())
        return 0; // nothing to do

    // Move the neighbor vertices to the other object
    auto cls = env->GetObjectClass(hashset);
    if (!cls) return -1;
    // HashSet<E>.add(E e) -- for templated parameters, use Object
    // TODO cache this reference
    auto add = env->GetMethodID(cls, "add", "(Ljava/lang/Object;)Z");
    if (!add) return -1;

    for (std::string &s : others)
        env->CallBooleanMethod(hashset, add,
                env->NewStringUTF(s.c_str()));

    return 0;
}

// int connect(String servers);
JNIEXPORT jint JNICALL Java_JNILinker_connect
  (JNIEnv *env, jobject thisobj, jstring servers)
{
    Lock lock;

    std::string s(J2C_string(env, servers));
    return funcs.connect(s);
}

// int imagesOf(String vertex, HashSet<String> keys);
JNIEXPORT jint JNICALL Java_JNILinker_imagesOf
  (JNIEnv *env, jobject thisobj, jstring vertex, jobject hashset)
{
    Lock lock;

    std::string v(J2C_string(env, vertex));
    std::deque<std::string> keys;
    if (0 != funcs.imagesOf(v, keys))
        return -1;
    if (0 == keys.size())
        return 0; // nothing to do

    auto cls = env->GetObjectClass(hashset);
    if (!cls) return -1;
    auto add = env->GetMethodID(cls, "add", "(Ljava/lang/Object;)Z");
    if (!add) return -1;

    for (std::string &s : keys)
        env->CallBooleanMethod(hashset, add,
                env->NewStringUTF(s.c_str()));

    return 0;
}

// int feature(String image_key);
JNIEXPORT jint JNICALL Java_JNILinker_feature
  (JNIEnv *env, jobject thisobj, jstring image_key)
{
    Lock lock;

    std::string key(J2C_string(env, image_key));
    int num;
    return !!funcs.feature(key, num);
}

// int match(HashSet<String> image_keys);
JNIEXPORT jint JNICALL Java_JNILinker_match
  (JNIEnv *env, jobject thisobj, jobject hashset)
{
    Lock lock;

    std::deque<cv::detail::MatchesInfo> matchinfo;
    std::deque<std::string> keys;

    keys = J2C_hashset(env, hashset);
    if (keys.size() == 0)
        return -1;

#if 0 // fucking opencv asserts make me want to die
    if (funcs.match(keys, matchinfo))
        return -1;

    // pick images above some threshold size
    size_t num = keys.size();
    if (num > 16)
        num = static_cast<size_t>(std::log1p(keys.size())) << 2;
    auto comp = [](const cv::detail::MatchesInfo &a,
            const cv::detail::MatchesInfo &b) {
        return !!(a.confidence < b.confidence);
    };
    std::sort(matchinfo.begin(), matchinfo.end(), comp);
    while (matchinfo.size() > num)
        matchinfo.erase(matchinfo.end() - 1);
#else
    size_t num = keys.size();
    if (num > 16)
        num = static_cast<size_t>(std::log1p(keys.size())) << 2;
    while (keys.size() > num)
        keys.erase(keys.end());
#endif

    C2J_hashset(env, keys, hashset);

    return 0;
}

// int montage(HashSet<String> imageKeys, String montage_key);
JNIEXPORT jint JNICALL Java_JNILinker_montage
  (JNIEnv *env, jobject thisobj, jobject hashset, jobject montage_key)
{
    Lock lock;

    std::deque<std::string> keys;
    std::string key;

    keys = J2C_hashset(env, hashset);
    if (keys.size() == 0) {
        jthrow(env, "converted hashset is empty");
        return -1;
    }

    try { // pass errors up from c++
        funcs.montage(keys, key);
    } catch(std::exception &e) {
        jthrow(env, e.what());
        return -1;
    }

    // update montage_key
    jclass cls = env->GetObjectClass(montage_key);
    jcheck(env);
    jmethodID append = env->GetMethodID(cls,
            "append", "(Ljava/lang/String;)Ljava/lang/StringBuffer;");
    jcheck(env);
    env->CallObjectMethod(montage_key, append,
            env->NewStringUTF(key.c_str()));
    jcheck(env);

    return 0;
}

// int writeImage(String key, String path);
JNIEXPORT jint JNICALL Java_JNILinker_writeImage
  (JNIEnv *env, jobject thisobj, jstring jkey, jstring jpath)
{
    Lock lock;

    std::string key = J2C_string(env, jkey);
    std::string path = J2C_string(env, jpath);

    try {
        funcs.writeImage(key, path);
    } catch (std::exception &e) {
        jthrow(env, e.what());
        return -1;
    }

    return 0;
}

